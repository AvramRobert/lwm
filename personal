PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX lwm: <http://lwm.gm.fh-koeln.de/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

---- PREVIOUS SWAP METHOD ------

 val studentIndividual = Individual(Resource(student.get))
          val oldGroupIndividual = Individual(Resource(oldGroup.get))
          val newGroupIndividual = Individual(Resource(newGroup.get))

          def statementInsertion(entryWithSchedule: Resource, group: Resource) = {
            val query =
              s"""
          select distinct ?s ?p ?o where {
          $group ${LWM.hasScheduleAssociation} ?newGroup .
          $entryWithSchedule ${LWM.hasScheduleAssociation} ?s .
          ?newGroup ${LWM.hasAssignmentAssociation} ?assoc .
          ?s ${LWM.hasAssignmentAssociation} ?assoc .
          ?newGroup ?p ?o .
          filter(?p != ${RDF.typ} && ?p != ${LWM.hasAssignmentAssociation} && ?p != ${OWL.NamedIndividual})
          }
          """.stripMargin

            sparqlExecutionContext.executeQuery(query).map { result ⇒
              val statements = SPARQLTools.statementsFromString(result).map(r ⇒ (r.s, r.p, r.o))
              val update = buildQuery("insert", statements)
              //println(s"Insert: \n$update")
              sparqlExecutionContext.executeUpdate(update)
            }
          }
          def statementRemoval(entryWithSchedule: Resource, group: Resource) = {
            val query =
              s"""
          select ?s ?p ?o where {
            $entryWithSchedule ${LWM.hasScheduleAssociation} ?s .
            ?s ${LWM.hasGroup} $group .
            ?s ?p ?o .
            filter(?p != ${RDF.typ} && ?p != ${LWM.hasAssignmentAssociation} && ?p != ${OWL.NamedIndividual} && ?p != ${LWM.hasPassed} && ?p != ${LWM.hasAttended})
          }
          """.stripMargin

            sparqlExecutionContext.executeQuery(query).map { result ⇒
              val statements = SPARQLTools.statementsFromString(result).map(r ⇒ (r.s, r.p, r.o))
              val update = buildQuery("delete", statements)
              //println(s"Remove: \n$update")
              sparqlExecutionContext.executeUpdate(update)
            }
          }

          def buildQuery(op: String, map: Seq[(Resource, Property, RDFNode)]): String = {
            val builder = new StringBuilder
            if (op == "delete") builder.append("DELETE DATA { ") else builder.append("INSERT DATA { ")
            map.foreach {
              e ⇒
                builder.append(s"${e._1} ${e._2} ${e._3.toQueryString} . ")
            }
            builder.deleteCharAt(builder.length - 2)
            builder.append("}")
            builder.toString()
          }

          for {
            deleteStage1 ← statementRemoval(studentIndividual.uri, oldGroupIndividual.uri)
            deleteStage2 ← deleteStage1
            insertStage1 ← statementInsertion(studentIndividual.uri, newGroupIndividual.uri)
            insertStage2 ← insertStage1
          } yield {
            studentIndividual.update(LWM.memberOf, oldGroupIndividual.uri, newGroupIndividual.uri)
            oldGroupIndividual.remove(LWM.hasMember, studentIndividual.uri)
            newGroupIndividual.add(LWM.hasMember, studentIndividual.uri)
            Redirect(routes.GroupManagementController.index(oldGroupIndividual.props.getOrElse(LWM.hasLabWork, List(Resource(""))).head.value, oldGroupIndividual.uri.value))
          }

 --------------------------------------